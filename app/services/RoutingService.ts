// app/services/RoutingService.ts

import { Logs, writeFile, requiredCall } from '../controllers2/Utils/functions.js' 
import env from '#start/env'
import Store from '#models/store'
import Theme from '#models/theme'
import { execa } from 'execa'
import fs from 'fs/promises'
import path from 'path'
import Api from '#models/api'

// Constantes pour les chemins Nginx
export const NGINX_SITES_AVAILABLE = '/etc/nginx/sites-available';
export const NGINX_SITES_ENABLED = '/etc/nginx/sites-enabled';
export const SERVER_CONF_NAME = 'sublymus_server';

// Helper pour s'assurer que les r√©pertoires Nginx existent
async function ensureNginxDirsExist(): Promise<boolean> {
    try {
        await fs.stat(NGINX_SITES_AVAILABLE);
        await fs.stat(NGINX_SITES_ENABLED);
        return true;
    } catch (error) {
        console.error("Erreur: Les r√©pertoires Nginx n'existent pas ou ne sont pas accessibles.", error);
        return false;
    }
}

/**
 * Fonction pour effectivement tester et recharger Nginx.
 * Sera appel√©e via le debounce/requiredCall.
 */
async function _applyNginxReload(): Promise<boolean> {
    const logs = new Logs('RoutingService._applyNginxReload');
    try {
        logs.log('üß™ Test de la configuration Nginx...');
        await execa('sudo', ['nginx', '-t']);
        logs.log('‚úÖ Configuration Nginx valide.');
        logs.log('üöÄ Rechargement de Nginx...');
        await execa('sudo', ['systemctl', 'reload', 'nginx']);
        logs.log('‚úÖ Nginx recharg√© avec succ√®s.');
        return true;
    } catch (error: any) {
        logs.notifyErrors('‚ùå Erreur lors du test ou du rechargement de Nginx', {}, error);
        if (error.stderr) {
            logs.log("--- Nginx Error Output ---");
            logs.log(error.stderr);
            logs.log("--------------------------");
        }
        return false;
    }
}

// --- Instance de RoutingService (Singleton) ---
class RoutingServiceClass {

    /**
     * D√©clenche un rechargement Nginx (d√©bounc√©).
     */
    async triggerNginxReload(): Promise<void> {
        // Utilise requiredCall pour d√©bouncer l'appel √† _applyNginxReload
        await requiredCall(_applyNginxReload);
    }

    /**
     * Met √† jour la configuration Nginx pour un store sp√©cifique (domaines custom).
     * @param store Le Store concern√©.
     * @param triggerReload Indique s'il faut d√©clencher un rechargement (d√©bounc√©) apr√®s l'√©criture.
     * @returns Succ√®s de l'√©criture et de l'activation du fichier (hors reload).
     */
    async updateStoreRouting(store: Store, triggerReload = true): Promise<boolean> {
        const logs = new Logs(`RoutingService.updateStoreRouting (${store.id})`);
        if (!(await ensureNginxDirsExist())) return false;

        const confFileName = `${store.id}.conf`;
        const confFilePathAvailable = path.join(NGINX_SITES_AVAILABLE, confFileName);
        const confFilePathEnabled = path.join(NGINX_SITES_ENABLED, confFileName);

        // Si pas de domaines custom, on supprime la conf existante
        if (!store.domain_names || store.domain_names.length === 0) {
            // Appelle remove SANS d√©clencher de reload ici, le reload global suivra si n√©cessaire
            const removed = await this.removeStoreRoutingById(store.id, false);
             // Si la suppression a potentiellement chang√© l'√©tat et qu'un reload est demand√©
             if (removed && triggerReload) await this.triggerNginxReload();
             return removed; // Retourne le succ√®s de la suppression
        }

        // --- G√©n√©ration de la Configuration ---
        const themeId = store.current_theme_id || '';
        const themeServiceName = themeId ? `theme_${themeId}` : `api_store_${store.id}`;
        let targetPort: number;

        try {
             // Utilise la DB pour r√©cup√©rer le port interne (plus fiable)
            if (themeId) {
                 const theme = await Theme.find(themeId);
                 if (!theme) throw new Error(`Th√®me ${themeId} non trouv√© pour le port.`);
                targetPort = theme.internal_port;
             } else {
                 // Pour l'API, r√©cup√©rer celle associ√©e au store si possible, sinon la default
                 let api = store.current_api_id ? await Api.find(store.current_api_id) : null;
                 if (!api) api = await Api.findDefault();
                 if (!api) throw new Error(`API (sp√©cifique ou d√©faut) non trouv√©e pour le port.`);
                targetPort = api.internal_port;
             }
             if (!targetPort) throw new Error(`Port interne non trouv√© pour le service ${themeServiceName}`);

        } catch (portError) {
            logs.notifyErrors(`‚ùå Erreur r√©cup√©ration port pour '${themeServiceName}'`, { storeId: store.id }, portError);
            return false;
        }

        const domainList = store.domain_names.join(' ');
        const nginxConfig = `
# Config Store ${store.id} (${store.name}) - Domains: ${domainList}
# Target Service: ${themeServiceName}:${targetPort}
server {
    listen 80;
    # listen [::]:80;
    server_name ${domainList};

    # access_log /var/log/nginx/store_${store.id}.access.log;
    # error_log /var/log/nginx/store_${store.id}.error.log;

    location / {
        resolver 127.0.0.11 valid=10s;
        set $target_service http://${themeServiceName}:${targetPort};

        proxy_pass $target_service;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    # TODO: Add SSL/TLS config here
}`;
        // --- √âcriture et Activation ---
        try {
            logs.log(`üìù √âcriture config Nginx (via sudo tee): ${confFilePathAvailable}`);
            await writeFile(confFilePathAvailable, nginxConfig); // TODO debounce

            logs.log(`üîó Activation site Nginx (symlink)...`);
            try {
                // G√®re la cr√©ation/mise √† jour du lien symbolique avec sudo si n√©cessaire
                 await fs.unlink(confFilePathEnabled).catch(e => { if (e.code !== 'ENOENT') throw e; });
                 await fs.symlink(confFilePathAvailable, confFilePathEnabled);
             } catch (symlinkError: any) {
                 if (symlinkError.code === 'EACCES' || symlinkError.code === 'EPERM') {
                     logs.log("   -> Cr√©ation/M√†J lien n√©cessite sudo...");
                     try {
                         await execa('sudo', ['ln', '-sf', confFilePathAvailable, confFilePathEnabled]);
                     } catch (sudoSymlinkError) {
                         logs.notifyErrors(`‚ùå Erreur lien (sudo) pour store ${store.id}`, {}, sudoSymlinkError);
                         throw sudoSymlinkError;
                     }
                 } else { throw symlinkError; }
             }
            logs.log(`‚úÖ Config Nginx pour store ${store.id} mise √† jour.`);

            // D√©clenche le reload (d√©bounc√©) si demand√©
            if (triggerReload) {
                await this.triggerNginxReload();
            }
            return true;

        } catch (error) {
            logs.notifyErrors(`‚ùå Erreur √©criture/activation config Nginx pour ${store.id}`, {}, error);
            return false;
        }
    }

    /**
     * Supprime la configuration Nginx pour un store sp√©cifique.
     * @param storeId L'ID du store (ou BASE_ID).
     * @param triggerReload Indique s'il faut d√©clencher un rechargement (d√©bounc√©) apr√®s la suppression.
     * @returns boolean Succ√®s de la suppression (des fichiers/liens).
     */
    async removeStoreRoutingById(storeId: string, triggerReload = true): Promise<boolean> {
        const logs = new Logs(`RoutingService.removeStoreRoutingById (${storeId})`);
        if (!(await ensureNginxDirsExist())) return false;

        const confFileName = `${storeId}.conf`;
        const confFilePathAvailable = path.join(NGINX_SITES_AVAILABLE, confFileName);
        const confFilePathEnabled = path.join(NGINX_SITES_ENABLED, confFileName);
        let needsReload = false;

        try {
             logs.log(`üóëÔ∏è Suppression fichier Nginx (sudo rm): ${confFilePathAvailable}`);
            // Utilise sudo rm -f pour ignorer les erreurs si absent mais g√©rer les perms
             await execa('sudo', ['rm', '-f', confFilePathAvailable]);
            needsReload = true; // Suppose qu'un changement a eu lieu
        } catch (error: any) {
            // En th√©orie, rm -f ne devrait pas √©chouer facilement sauf permission sudo elle-m√™me
             logs.notifyErrors(`‚ö†Ô∏è Erreur suppression ${confFilePathAvailable} (sudo rm)`, {}, error);
             // On continue quand m√™me √† essayer de supprimer le lien
        }

        try {
            logs.log(`üóëÔ∏è Suppression lien Nginx (sudo rm): ${confFilePathEnabled}`);
            await execa('sudo', ['rm', '-f', confFilePathEnabled]);
            needsReload = true;
        } catch (error: any) {
            logs.notifyErrors(`‚ö†Ô∏è Erreur suppression lien ${confFilePathEnabled} (sudo rm)`, {}, error);
        }

        // D√©clenche le reload d√©bounc√© SI on a potentiellement supprim√© qqch ET si demand√©
        if (needsReload && triggerReload) {
            await this.triggerNginxReload();
        }
        return !logs.errors.length; // Succ√®s s'il n'y a pas eu d'erreur bloquante lors des rm
    }

    /**
     * Met √† jour le fichier serveur principal (sublymus_server.conf).
     * @param triggerReload Indique s'il faut d√©clencher un rechargement (d√©bounc√©).
     * @returns boolean Succ√®s de l'√©criture/activation du fichier principal.
     */
    async updateServerRouting(triggerReload = true): Promise<boolean> {
        const logs = new Logs('RoutingService.updateServerRouting');
        if (!(await ensureNginxDirsExist())) return false;

        const confFileName = `${SERVER_CONF_NAME}.conf`;
        const confFilePathAvailable = path.join(NGINX_SITES_AVAILABLE, confFileName);
        const confFilePathEnabled = path.join(NGINX_SITES_ENABLED, confFileName);
        const mainDomain = env.get('SERVER_DOMAINE', 'sublymus.local'); // Mettre un domaine local par d√©faut
        const backendHost = env.get('HOST', '127.0.0.1'); // Pointer vers 127.0.0.1 par d√©faut
        const backendPort = env.get('PORT', '5555');

        try {
            logs.log(`‚öôÔ∏è G√©n√©ration config Nginx pour ${mainDomain}...`);
             const stores = await Store.query().where('is_active', true).orderBy('name', 'asc');
            let locationsBlocks = '';

            for (const store of stores) {
                 const themeId = store.current_theme_id || '';
                 const serviceName = themeId ? `theme_${themeId}` : `api_store_${store.id}`;
                 let targetPort: number;

                 try {
                     if (themeId) {
                         const theme = await Theme.find(themeId);
                          if (!theme) throw new Error(`Th√®me ${themeId} non trouv√©.`);
                         targetPort = theme.internal_port;
                     } else {
                          let api = store.current_api_id ? await Api.find(store.current_api_id) : null;
                          if (!api) api = await Api.findDefault();
                          if (!api) throw new Error(`API non trouv√©e pour store ${store.id}.`);
                         targetPort = api.internal_port;
                     }
                      if (!targetPort) throw new Error(`Port interne manquant pour ${serviceName}`);

                 } catch (portError) {
                     logs.logErrors(`‚ö†Ô∏è Store ${store.id} (${store.name}): impossible d√©terminer port pour ${serviceName}. Location ignor√©e.`, {}, portError);
                     continue;
                 }

                locationsBlocks += `
    # Store: ${store.name} (${store.id}) -> ${serviceName}:${targetPort}
    location /${store.slug}/ { # Utilise le slug pour le path
        resolver 127.0.0.11 valid=10s;
        set $target_service http://${serviceName}:${targetPort};
        proxy_pass $target_service/; # Ajoute le / final pour potentiellement aider √† la r√©√©criture

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Tentative de r√©√©criture pour enlever le pr√©fixe slug (requiert proxy_pass AVEC / final)
         rewrite ^/${store.slug}/(.*)$ /$1 break;
    }`;
            }

            const nginxConfig = `
# Config Domain: ${mainDomain} -> s_server backend: ${backendHost}:${backendPort}
server {
    listen 80 default_server; # 'default_server' important si aucun autre serveur 80 n'est default
    # listen [::]:80 default_server;
    server_name ${mainDomain} _; # √âcoute sur le domaine principal et comme serveur par d√©faut

    # Logs (optionnel)
    # access_log /var/log/nginx/${SERVER_CONF_NAME}.access.log;
    # error_log /var/log/nginx/${SERVER_CONF_NAME}.error.log warn;

    # --- Backend principal (s_server) ---
    location / {
        proxy_pass http://${backendHost}:${backendPort};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # --- Stores Actifs (locations bas√©es sur slug) ---
    ${locationsBlocks}

    # TODO: Config SSL/TLS
}`;
            logs.log(`üìù √âcriture config Nginx (via sudo tee): ${confFilePathAvailable}`);
            await writeFile(confFilePathAvailable, nginxConfig); // TODO debounce

            logs.log(`üîó Activation site principal (symlink)...`);
            try {
                 // Utilise sudo pour le lien pour √™tre s√ªr
                await execa('sudo', ['ln', '-sf', confFilePathAvailable, confFilePathEnabled]);
            } catch (sudoSymlinkError) {
                logs.notifyErrors(`‚ùå Erreur lien symbolique principal (sudo)`, {}, sudoSymlinkError);
                throw sudoSymlinkError;
            }
            logs.log('‚úÖ Config Nginx principale mise √† jour.');

            if (triggerReload) {
                await this.triggerNginxReload();
            }
            return true;

        } catch (error) {
            logs.notifyErrors(`‚ùå Erreur lors de la M√†J config Nginx principale`, {}, error);
            return false;
        }
    }

    /**
     * Supprime toutes les configurations Nginx g√©r√©es par Sublymus.
     * @param triggerReload D√©clenche un reload (d√©bounc√©) apr√®s suppression.
     */
    async removeAllManagedRouting(triggerReload = true): Promise<boolean> {
        const logs = new Logs('RoutingService.removeAllManagedRouting');
        if (!(await ensureNginxDirsExist())) return false;
        let allSuccess = true;
        let needsReload = false;

        logs.log('üßπ Suppression des configs Nginx Sublymus...');

        // Supprime la conf principale
        logs.log(`üîß Suppression config principale (${SERVER_CONF_NAME})`);
         // Appelle remove SANS reload pour ne pas le faire pour chaque fichier
         const mainRemoved = await this.removeStoreRoutingById(SERVER_CONF_NAME, false);
         if (mainRemoved) needsReload = true; // Si on a effectivement supprim√© qqch
         allSuccess = mainRemoved && allSuccess;

        // Supprime les confs des stores
        const stores = await Store.all();
        for (const store of stores) {
            logs.log(`üîß Suppression config store ${store.id}`);
            const removed = await this.removeStoreRoutingById(store.id, false);
            if (removed) needsReload = true;
            allSuccess = removed && allSuccess;
        }

        if (needsReload && triggerReload) {
            logs.log('üîÑ D√©clenchement reload Nginx (d√©bounc√©)...');
            await this.triggerNginxReload();
        } else {
            logs.log('‚ÑπÔ∏è Rechargement Nginx non d√©clench√©.');
        }

        if (allSuccess) logs.log('‚úÖ Toutes les configs Nginx supprim√©es/tent√©es.');
        else logs.notifyErrors('‚ùå Certaines configs Nginx n‚Äôont pas pu √™tre supprim√©es correctement.');

        return allSuccess;
    }
}

// Exporte une instance unique de la classe pour utilisation comme singleton
const RoutingService = new RoutingServiceClass();
export default RoutingService;