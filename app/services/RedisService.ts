// app/services/RedisService.ts

import { Logs } from '../Utils/functions.js'
import Store from '#models/store'
import Redis, { type Redis as RedisClient } from 'ioredis'
import { Queue, Worker } from 'bullmq'
import { EventEmitter } from 'node:events'
import env from '#start/env'

class RedisService {
  //@ts-ignore
  client: RedisClient;
  //   private subscriber: RedisClient | null = null; // Client d√©di√© pour Pub/Sub si besoin
  //   private publisher: RedisClient | null = null;  // Client d√©di√© pour Pub/Sub si besoin
  queues: Map<string, Queue> = new Map(); // Pour les queues BullMQ
  workers: Map<string, Worker> = new Map(); // Pour les workers BullMQ
  emitter: EventEmitter = new EventEmitter(); // EventEmitter pour les messages re√ßus par workers

  constructor() {
    if (process.argv.join('').includes('/ace')) return
    //@ts-ignore
    this.client = new Redis({
      host: env.get('REDIS_HOST', '127.0.0.1'),
      port: env.get('REDIS_PORT', '6379'),
      // password: env.get('REDIS_PASSWORD'),
      // lazyConnect: true, // Optionnel: connecter seulement quand n√©cessaire
      maxRetriesPerRequest: null, // Nombre max de tentatives si connexion √©choue
      enableReadyCheck: true, // V√©rifie si Redis est pr√™t avant d'envoyer des commandes
    });

    this.setupEventHandlers();

    // Initialiser Pub/Sub clients si n√©cessaire pour une autre logique (non BullMQ)
    // this.publisher = this.client.duplicate();
    // this.subscriber = this.client.duplicate();
    // this.subscriber.subscribe('channel_name', (err, count) => { /* ... */ });
    // this.subscriber.on('message', (channel, message) => { /* ... */ });
  }

  private setupEventHandlers(): void {
    this.client.on('connect', () => {
      console.log('üîå Connect√© √† Redis.');
    });
    this.client.on('ready', () => {
      console.log('‚úÖ Redis pr√™t.');
    });
    this.client.on('error', (error) => {
      console.error('‚ùå Erreur de connexion Redis:', error);
      // G√©rer les erreurs de connexion persistantes (arr√™ter l'app? mode d√©grad√©?)
    });
    this.client.on('reconnecting', () => {
      console.log('‚è≥ Tentative de reconnexion √† Redis...');
    });
    this.client.on('close', () => {
      console.log('üö™ Connexion Redis ferm√©e.');
    });
    this.client.on('end', () => {
      console.log('üèÅ Connexion Redis termin√©e d√©finitivement.');
      // G√©rer l'arr√™t d√©finitif (arr√™ter l'app?)
    });
  }

  // --- Fonctions Cache ---

  /**
   * Met une valeur en cache. S√©rialise automatiquement en JSON.
   * @param key La cl√© de cache.
   * @param value La valeur √† mettre en cache (peut √™tre un objet/tableau).
   * @param ttlSecondes Temps de vie en secondes (optionnel).
   */
  async setCache(key: string, value: any, ttlSecondes?: number): Promise<boolean> {
    const logs = new Logs(`RedisService.setCache (${key})`);
    try {
      const stringValue = JSON.stringify(value);
      if (ttlSecondes) {
        await this.client.set(key, stringValue, 'EX', ttlSecondes);
      } else {
        await this.client.set(key, stringValue);
      }
      // logs.log(`üíæ Cache d√©fini.`); // Peut √™tre trop verbeux
      return true;
    } catch (error) {
      logs.notifyErrors('‚ùå Erreur setCache Redis', { key }, error);
      return false;
    }
  }

  /**
   * R√©cup√®re une valeur du cache. D√©s√©rialise automatiquement depuis JSON.
   * @param key La cl√© de cache.
   * @returns La valeur d√©s√©rialis√©e, ou null si non trouv√© ou erreur.
   */
  async getCache<T = any>(key: string): Promise<T | null> {
    const logs = new Logs(`RedisService.getCache (${key})`);
    try {
      const stringValue = await this.client.get(key);
      if (!stringValue) {
        return null;
      }
      return JSON.parse(stringValue) as T;
    } catch (error) {
      // Peut √™tre une erreur JSON.parse ou une erreur Redis
      if (error instanceof SyntaxError) {
        logs.logErrors(`‚ö†Ô∏è Valeur non JSON dans le cache pour la cl√©`, { key }, error);
      } else {
        logs.notifyErrors('‚ùå Erreur getCache Redis', { key }, error);
      }
      return null;
    }
  }

  /**
   * Supprime une ou plusieurs cl√©s du cache.
   * @param keys La ou les cl√©s √† supprimer.
   * @returns Le nombre de cl√©s supprim√©es.
   */
  async deleteCache(...keys: string[]): Promise<number> {
    const logs = new Logs(`RedisService.deleteCache (${keys.join(', ')})`);
    if (keys.length === 0) return 0;
    try {
      const count = await this.client.del(keys);
      // logs.log(`üóëÔ∏è Cache supprim√©(s) : ${count}.`);
      return count;
    } catch (error) {
      logs.notifyErrors('‚ùå Erreur deleteCache Redis', { keys }, error);
      return 0;
    }
  }

  // --- Fonctions Cache Sp√©cifiques Store ---

  /**
   * Met en cache les informations d'un store sous son ID et son nom.
   * @param store L'objet Store.
   * @param previousName Nom pr√©c√©dent pour nettoyer l'ancien cache nom->id.
   * @param ttlSecondes Optionnel: dur√©e de vie du cache.
   */
  async setStoreCache(store: Store, previousName?: string, ttlSecondes?: number): Promise<void> {
    if (previousName && previousName !== store.name) {
      await this.deleteCache(this.getStoreNameKey(previousName));
    }
    const storeIdKey = this.getStoreIdKey(store.id);
    const storeNameKey = this.getStoreNameKey(store.name);

    // Transaction Redis pour assurer l'atomicit√© (ou au moins regrouper les appels)
    const multi = this.client.multi();
    const storeData = store.$attributes; // Ne stocker que les donn√©es s√©rialisables

    multi.set(storeIdKey, JSON.stringify(storeData));
    multi.set(storeNameKey, store.id); // Cl√© nom -> ID

    if (ttlSecondes) {
      multi.expire(storeIdKey, ttlSecondes);
      multi.expire(storeNameKey, ttlSecondes);
    }

    try {
      await multi.exec();
    } catch (error) {
      new Logs('RedisService.setStoreCache').notifyErrors('‚ùå Erreur transaction Redis', { storeId: store.id }, error);
    }
  }

  async getStoreCacheById(storeId: string): Promise<Store['$attributes'] | null> {
    return this.getCache<Store['$attributes']>(this.getStoreIdKey(storeId));
  }

  async getStoreCacheByName(storeName: string): Promise<Store['$attributes'] | null> {
    const storeId = await this.getCache<string>(this.getStoreNameKey(storeName));
    if (!storeId) return null;
    return this.getStoreCacheById(storeId);
  }

  async deleteStoreCache(store: Store): Promise<void> {
    await this.deleteCache(
      this.getStoreIdKey(store.id),
      this.getStoreNameKey(store.name)
    );
  }

  // M√©thodes pour obtenir les cl√©s de cache standardis√©es
  private getStoreIdKey(storeId: string): string { return `store+id+${storeId}`; }
  private getStoreNameKey(storeName: string): string { return `store+name:+${storeName}`; }
  

  // --- Fonctions de Communication (remplace RedisBidirectional) ---

  /**
   * Assure qu'une queue et un worker BullMQ existent pour un service (bas√© sur BASE_ID).
   * Cr√©e le canal s'il n'existe pas. Con√ßu pour √™tre appel√© sans risque plusieurs fois.
   *
   * @param baseId Identifiant unique du canal de communication (ex: storeId, themeId).
   */
  async ensureCommunicationChannel(baseId: string): Promise<void> {
    const logs = new Logs(`RedisService.ensureCommunicationChannel (${baseId})`);
    if (this.workers.has(baseId) && this.queues.has(baseId)) {
      // logs.log('‚ÑπÔ∏è Canal de communication d√©j√† initialis√©.');
      return; // D√©j√† initialis√©
    }

    const queueName = `server-to-service+${baseId}`; // Queue pour envoyer des messages AU service
    const workerName = `service-to-server+${baseId}`; // Queue pour recevoir des messages DU service

    try {
      // Cr√©e la queue si elle n'existe pas
      if (!this.queues.has(baseId)) {
        const queue = new Queue(queueName, {
          connection: this.client.duplicate(), // Utilise une connexion d√©di√©e pour BullMQ
          defaultJobOptions: { // Options par d√©faut pour les jobs
            attempts: 3, // 3 essais en cas d'√©chec
            backoff: { type: 'exponential', delay: 1000 }, // Backoff exponentiel
            removeOnComplete: true, // Nettoie les jobs r√©ussis
            removeOnFail: 1000 // Garde les 1000 derniers jobs √©chou√©s
          }
        });
        this.queues.set(baseId, queue);
        logs.log(`‚úÖ Queue BullMQ '${queueName}' cr√©√©e/attach√©e.`);
      }

      // Cr√©e le worker s'il n'existe pas
      if (!this.workers.has(baseId)) {
        const worker = new Worker(
          workerName,
          async (job) => {
            // √âmettre un √©v√©nement sur l'emitter local quand un message est re√ßu
            const eventName = `${baseId}+${job.data.event || 'message'}`;
            logs.log(`üì¨ Message re√ßu sur '${workerName}', event='${job.data.event}', emission='${eventName}'`);
            this.emitter.emit(eventName, job.data.data); // √âmet data.data
            this.emitter.emit(baseId, job.data);       // √âmet l'objet job.data complet
          },
          {
            connection: this.client.duplicate(), // Connexion d√©di√©e
            concurrency: 5, // Traite jusqu'√† 5 messages en parall√®le
          }
        );

        worker.on('failed', (job, err) => {
          logs.logErrors(`‚ùå Job '${job?.id}' a √©chou√© sur '${workerName}'`, { job }, err);
        });
        worker.on('error', err => {
          logs.notifyErrors(`‚ùå Erreur Worker BullMQ '${workerName}'`, {}, err);
        });

        this.workers.set(baseId, worker);
        logs.log(`‚úÖ Worker BullMQ '${workerName}' cr√©√©/attach√©.`);
      }

    } catch (error) {
      logs.notifyErrors(`‚ùå Erreur lors de la cr√©ation/attachement du canal de communication pour ${baseId}`, {}, error);
      // Nettoyer partiellement cr√©√© ?
      await this.closeCommunicationChannel(baseId); // Tenter de fermer en cas d'√©chec partiel
    }
  }

  /**
   * Envoie un message √† un service via sa queue BullMQ.
   * Assure que le canal existe avant d'envoyer.
   *
   * @param baseId L'ID du service cible.
   * @param event Le type d'√©v√©nement/message (ex: 'request_scale', 'config_update').
   * @param data Les donn√©es associ√©es √† l'√©v√©nement.
   * @returns boolean Succ√®s de l'ajout √† la queue.
   */
  async sendMessageToService(baseId: string, event: string, data: any): Promise<boolean> {
    const logs = new Logs(`RedisService.sendMessageToService (${baseId})`);
    try {
      await this.ensureCommunicationChannel(baseId); // S'assure que la queue existe
      const queue = this.queues.get(baseId);
      if (!queue) {
        throw new Error(`Queue pour ${baseId} non trouv√©e apr√®s initialisation.`);
      }
      const jobName = event; // Utiliser l'√©v√©nement comme nom de job pour le suivi
      await queue.add(jobName, { event, data });
      logs.log(`‚úÖ Message '${event}' envoy√© √† la queue pour ${baseId}.`);
      return true;
    } catch (error) {
      logs.notifyErrors(`‚ùå Erreur lors de l'envoi du message '${event}' √† ${baseId}`, { data }, error);
      return false;
    }
  }

  /**
  * Ferme proprement la queue et le worker BullMQ pour un service.
  * √Ä appeler lors de la suppression d√©finitive du service.
  *
  * @param baseId L'ID du canal √† fermer.
  */
  async closeCommunicationChannel(baseId: string): Promise<void> {
    const logs = new Logs(`RedisService.closeCommunicationChannel (${baseId})`);
    const queue = this.queues.get(baseId);
    const worker = this.workers.get(baseId);
    let closed = false;

    if (queue) {
      try {
        await queue.close();
        logs.log(`‚úÖ Queue BullMQ pour ${baseId} ferm√©e.`);
        this.queues.delete(baseId);
        closed = true;
      } catch (error) {
        logs.notifyErrors(`‚ùå Erreur fermeture queue ${baseId}`, {}, error);
      }
    }

    if (worker) {
      try {
        await worker.close();
        logs.log(`‚úÖ Worker BullMQ pour ${baseId} ferm√©.`);
        this.workers.delete(baseId);
        closed = true;
      } catch (error) {
        logs.notifyErrors(`‚ùå Erreur fermeture worker ${baseId}`, {}, error);
      }
    }
    // Si un canal √©tait actif, on supprime les listeners associ√©s
    if (closed) {
      this.emitter.removeAllListeners(baseId);
      // Supprimer aussi les listeners sp√©cifiques `baseId:event` peut √™tre plus complexe
      // Garder une trace des listeners cr√©√©s pourrait √™tre n√©cessaire.
      // Pour l'instant, on laisse l'emitter global se vider par manque de references.
    }
  }

  /**
  * Ferme proprement toutes les connexions Redis, les queues et workers.
  * √Ä appeler lors de l'arr√™t gracieux de s_server.
  */
  async shutdown(): Promise<void> {
    console.log('üîå Fermeture de RedisService...');
    // Ferme tous les workers et queues BullMQ
    const closePromises = [
      ...Array.from(this.workers.keys()).map(id => this.closeCommunicationChannel(id)),
      // N'attend pas explicitement la fermeture des workers/queues ci-dessus pour acc√©l√©rer
    ];
    await Promise.allSettled(closePromises); // Tente de tout fermer
    this.workers.clear();
    this.queues.clear();

    // Ferme les clients ioredis
    await this.client.quit();
    // await this.subscriber?.quit();
    // await this.publisher?.quit();
    console.log('‚úÖ RedisService arr√™t√©.');
  }
}

// Exporte une instance unique (Singleton)
export default new RedisService();

// Assurer l'arr√™t propre lors de la fermeture de l'application
process.on('SIGINT', async () => {
  console.log('SIGINT re√ßu, arr√™t de RedisService...');
  const redisService = new RedisService();
  await redisService.shutdown();
  process.exit(0);
});
process.on('SIGTERM', async () => {
  const redisService = new RedisService();
  console.log('SIGTERM re√ßu, arr√™t de redisService...');
  await redisService.shutdown();
  process.exit(143); // Code standard pour SIGTERM
});